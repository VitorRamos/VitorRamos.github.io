:source-highlighter: coderay
:stem:
:toc: left

= Processamento Digital de Imagens Exercicios =

Vitor Ramos <vitorramos89@gmail.com>

== Introducao ==

introducao 

== Manipulando pixels em uma imagem ==
:pastaExercicio321: Regioes/

=== Exercício 1 ===

Implementar de um programa que deverá solicitar ao usuário as coordenadas de dois pontos stem:[P_1] e stem:[P_2] localizados dentro dos limites do tamanho da imagem que lhe for fornecida e exibir. Entretanto, a região definida pelo retângulo de vértices opostos definidos pelos pontos stem:[P_1] e stem:[P_2] será exibida com o negativo da imagem na região correspondente.

.O codigo
[source,c++]
----
include::{pastaExercicio321}/main.cpp[]
----

.Imagem Original
image:{pastaExercicio321}/biel.png[]

.Resultado
image:{pastaExercicio321}/resultado.png[]


:pastaExercicio322: TrocaRegioes/
=== Exercício 2 ===
Implementar um programa que deverar trocar aleatoriamente regiões da imagem, formando uma espécie de quebra-cabeças. Explore o uso da classe Mat e seus construtores para criar as regiões que serão trocadas. O efeito é ilustrado na Figura Troca de regiões.

.O codigo
[source,c++]
----
include::{pastaExercicio322}/main.cpp[]
----

.Imagem Original
image:{pastaExercicio322}/abc.jpg[]

.Resultado 1
image:{pastaExercicio322}/resultado.png[]

.Resultado 2
image:{pastaExercicio322}/resultado2.png[]


== Preenchendo regiões ==

:pastaExercicio421: ContaObjeto/

=== Exercício 1 ===
Observando-se o programa labeling.cpp como exemplo, é possível verificar que caso existam mais de 255 objetos na cena, o processo de rotulação poderá ficar comprometido. Identifique a situação em que isso ocorre e proponha uma solução para este problema.

Isso ocorre porque para cada objeto é atribuido um valor de cinza, se a imagem tive mais de 255 objetos o programa vai atribuir valores invalidos de cinza pois a imagem só possui 8 bits, a solução é fixar o valor de cinza dos objetos encontrados 


.Codigo Original
[source,c++]
----
include::{pastaExercicio421}/labeling.cpp[]
----

.Linha Subistituida
[source,c++]
----
...
floodFill(image,p,50);
...
----

.Imagem Original
image:{pastaExercicio421}/abc.png[]

.Resultado
image:{pastaExercicio421}/resultado.png[]


:pastaExercicio422: ContaBuraco/

=== Exercício 2 ===
Aprimoração do algoritmo de contagem apresentado para identificar regiões com ou sem buracos internos. Assumindo que objetos com mais de um buraco podem existir. Incluindo suporte no seu algoritmo para não contar bolhas que tocam as bordas da imagem.

.O Codigo
[source,c++]
----
include::{pastaExercicio422}/main.cpp[]
----

.Resultado
image:{pastaExercicio422}/resultado.png[]

== Manipulação de histogramas ==

:pastaExercicio521: HistogramaEqualizacao/
=== Exercício 1 ===
Utilizando o programa exemplos/histogram.cpp como referência. Implemente um programa equalize.cpp. Este deverá, para cada imagem capturada, realizar a equalização do histogram antes de exibir a imagem.

.O Codigo
[source,c++]
----
include::{pastaExercicio521}/main.cpp[]
----

:pastaExercicio522: MotionDetec/
=== Exercício 2 ===
Utilizando o programa exemplos/histogram.cpp como referência, implemente um programa motiondetector.cpp. Este deverá continuamente calcular o histograma da imagem (apenas uma componente de cor é suficiente) e compará-lo com o último histograma calculado. Quando a diferença entre estes ultrapassar um limiar pré-estabelecido, ative um alarme. Utilize uma função de comparação que julgar conveniente.

.O Codigo
[source,c++]
----
include::{pastaExercicio522}/main.cpp[]
----

== Conclusão ==

conclusao

== Bibliografia ==
[bibliography]
- http://docs.opencv.org/ - Principal portal de documentação OpenCV.
- http://agostinhobritojr.github.io/tutoriais/pdi/. - Site de referência para as tarefas em OpenCV.
