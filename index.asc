:source-highlighter: coderay
:stem:
:toc: left
:toc-title: Sumario

= Processamento Digital de Imagens Exercicios =

Vitor Ramos <vitorramos89@gmail.com>

== Introducao ==

introducao 

== Manipulando pixels em uma imagem ==
:pastaExercicio321: Regioes/

=== Exercício 1 ===

Implementar de um programa que deverá solicitar ao usuário as coordenadas de dois pontos stem:[P_1] e stem:[P_2] localizados dentro dos limites do tamanho da imagem que lhe for fornecida e exibir. Entretanto, a região definida pelo retângulo de vértices opostos definidos pelos pontos stem:[P_1] e stem:[P_2] será exibida com o negativo da imagem na região correspondente.

.O codigo
[source,c++]
----
include::{pastaExercicio321}/main.cpp[]
----

.Imagem Original
image:{pastaExercicio321}/biel.png[]

.Resultado
image:{pastaExercicio321}/resultado.png[]


:pastaExercicio322: TrocaRegioes/
=== Exercício 2 ===
Implementar um programa que deverar trocar aleatoriamente regiões da imagem, formando uma espécie de quebra-cabeças. Explore o uso da classe Mat e seus construtores para criar as regiões que serão trocadas. O efeito é ilustrado na Figura Troca de regiões.

.O codigo
[source,c++]
----
include::{pastaExercicio322}/main.cpp[]
----

.Imagem Original
image:{pastaExercicio322}/abc.jpg[]

.Resultado 1
image:{pastaExercicio322}/resultado.png[]

.Resultado 2
image:{pastaExercicio322}/resultado2.png[]


== Preenchendo regiões ==

:pastaExercicio421: ContaObjeto/

=== Exercício 1 ===
Observando-se o programa labeling.cpp como exemplo, é possível verificar que caso existam mais de 255 objetos na cena, o processo de rotulação poderá ficar comprometido. Identifique a situação em que isso ocorre e proponha uma solução para este problema.

Solucao : Isso ocorre porque para cada objeto é atribuido um valor de cinza, se a imagem tive mais de 255 objetos o programa vai atribuir valores invalidos de cinza pois a imagem só possui 8 bits, a solução é fixar o valor de cinza dos objetos encontrados assim o programa podera classificar quantos objetos tiver na imagem.


.Codigo Modificado
[source,c++]
----
include::{pastaExercicio421}/main.cpp[]
----


.Imagem Original
image:{pastaExercicio421}/abc.png[]

.Resultado
image:{pastaExercicio421}/resultado.png[]


:pastaExercicio422: ContaBuraco/

=== Exercício 2 ===
Aprimoração do algoritmo de contagem apresentado para identificar regiões com ou sem buracos internos. Assumindo que objetos com mais de um buraco podem existir. Incluindo suporte no seu algoritmo para não contar bolhas que tocam as bordas da imagem.

.O Codigo
[source,c++]
----
include::{pastaExercicio422}/main.cpp[]
----

.Resultado
image:{pastaExercicio422}/resultado.png[]
Para testar o codigo foram criados objetos com mais de um buraco e o programa contou ele apenas uma vez como esperado

== Manipulação de histogramas ==

:pastaExercicio521: HistogramaEqualizacao/
=== Exercício 1 ===
Utilizando o programa exemplos/histogram.cpp como referência. Implemente um programa equalize.cpp. Este deverá, para cada imagem capturada, realizar a equalização do histogram antes de exibir a imagem.

o programa a seguir equaliza os 3 canais de cores RGB individualmente

.O Codigo
[source,c++]
----
include::{pastaExercicio521}/main.cpp[]
----

.Resultado utilizando 64 beans
image:{pastaExercicio521}/resultado64beans.png[]

.Resultados utilizando 256 beans
image:{pastaExercicio521}/resultado256beans.png[]
image:{pastaExercicio521}/resultado256_2beans.png[]

é possivel obervar a homogeneização do histograma e as cores mais vivas 

:pastaExercicio522: MotionDetec/
=== Exercício 2 ===
Utilizando o programa exemplos/histogram.cpp como referência, implemente um programa motiondetector.cpp. Este deverá continuamente calcular o histograma da imagem (apenas uma componente de cor é suficiente) e compará-lo com o último histograma calculado. Quando a diferença entre estes ultrapassar um limiar pré-estabelecido, ative um alarme. Utilize uma função de comparação que julgar conveniente.

O programa utiliza apenas o canal R para calcular a diferença do histograma, e a diferença e calculada pela função chi-quadrado stem:[$$\sum_{k=1}^{\n} (histR[k]-prevHistR[k])^2/(histR[k])$$]

.O Codigo
[source,c++]
----
include::{pastaExercicio522}/main.cpp[]
----

== Filtragem no domínio espacial ==

:pastaExercicio62: Laplgauss/
=== Exercício 1 ===
Utilizando o programa exemplos/filtroespacial.cpp como referência, Implementar um programa laplgauss.cpp. O programa deverá acrescentar mais uma funcionalidade ao exemplo fornecido, permitindo que seja calculado o laplaciano do gaussiano das imagens capturadas.

.O Codigo
[source,c++]
----
include::{pastaExercicio62}/main.cpp[]
----

.Resultado utilizando filtro gaussiano
image:{pastaExercicio62}/gauss.png[]

.Resultado utilizando filtro laplaciano
image:{pastaExercicio62}/laplace.png[]

.Resultado utilizando filtro laplaciano do gaussiano
image:{pastaExercicio62}/lagauss.png[]

foi verificado que ao utilizar o filtro gaussiano antes do laplaciano faz muito diferença pois o filtro gaussiano elimina pequenos ruidos que existem na imagem e o laplaciano consegue distinguir melhor as bordas

== Conclusão ==

conclusao

== Bibliografia ==
[bibliography]
- http://docs.opencv.org/ - Principal portal de documentação OpenCV.
- http://agostinhobritojr.github.io/tutoriais/pdi/. - Site de referência para as tarefas em OpenCV.
